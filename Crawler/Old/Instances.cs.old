namespace Crawler;

class Component {
    public Component(ComponentSpec Spec) {
        this.Spec = Spec;
        Armor = Spec.ArmorMax;
        Hull = Spec.HullMax;
        Enabled = true;
        Powered = false;
    }
    public ComponentSpec Spec { get; private set; }

    // State
    //---------------------------------------------------
    public float Armor;
    public float Hull;
    public bool Enabled; // turned on
    public bool Powered; // getting powered

    virtual public IEnumerable<Component> Tree { get { yield return this; } }
    virtual public string TypeName => Spec.GetType().Name;

    public float TotalArmor => Tree.Sum(c => c.Armor);
    public float TotalHull => Tree.Sum(c => c.Hull);

    public float TotalArmorMax => Tree.Sum(c => c.Spec.ArmorMax);
    public float TotalHullMax => Tree.Sum(c => c.Spec.HullMax);
    public float TotalPowerUsed => Tree.Sum(c => c.Spec.PowerUsed);
    public float TotalMass => Tree.Sum(c => c.Spec.Mass);

    public string Ratio(float a, float b) {
        if (a < 0) {
            return "???";
        } else if (b <= 0) {
            return "---";
        } else if (a >= b) {
            return "***";
        } else {
            int r = ( int ) (a * 100 / b);
            r = Math.Clamp(r, 0, 99);
            return $"{r:G3}%";
        }
    }

    public string EnabledText => Enabled ? "ON " : "OFF";
    public string PoweredText => Powered ? "LIVE" : "DEAD";

    bool Activated => Enabled && Powered;
    public override string ToString() => $"{Spec}";
    public string TreeString => string.Join("\n", Tree.Select(c => c.LongString));
    public virtual string LongString {
        get {
            string result = $"{TypeName}[{Spec.UniqueKey,-32}] {EnabledText} {PoweredText}";
            result += $" AR{Armor,4}/{Spec.ArmorMax,4} HL{Hull,4}/{Spec.HullMax,4}";
            return result;
        }
    }
}

class Socket: Component
{
    public Socket(Segment segment, FitmentSpec fitmentSpec): base(fitmentSpec.Socket!)
    {
        FitmentSpec = fitmentSpec;
        Segment = segment;

        if (fitmentSpec.Socketable is TractionSpec tractionSpec) {
            Socketed = new Traction(this, tractionSpec);
        }
        // TODO: Actually create Socketable
    }

    public FitmentSpec FitmentSpec { get; private set; }
    public SocketSpec SocketSpec => (Spec as SocketSpec)!;
    public SocketType Type => SocketSpec.SocketType;
    public Side Side => FitmentSpec.Side;

    public Socketable? Socketed { get; set; }

    public readonly Segment Segment;

    public override string ToString() => $"{SocketSpec} {Side} {Type}";
    public override string LongString => base.LongString + $":{Side} {Type}";

    public override IEnumerable<Component> Tree {
        get {
            yield return this;
            if (Socketed != null) {
                foreach (var c in Socketed.Tree) {
                    yield return c;
                }
            }
        }
    }
    override public string TypeName => "   Socket";
}

class Segment: Component
{
    public Segment(Crawler crawler, SegmentSpec spec): base(spec)
    {
        foreach (FitmentSpec fitment in SegmentSpec.Fitments) {
            if (fitment.Socket == null) {
                continue;
            }
            if (!Sockets.TryGetValue(fitment.Side, out var sockets)) {
                sockets = new List<Socket>();
                Sockets.Add(fitment.Side, sockets);
            }
            for (int i = 0; i < fitment.Count; i++) {
                var newSocket = new Socket(this, fitment);
                Sockets[fitment.Side].Add(newSocket);
            }
        }
        Crawler = crawler;
    }

    public SegmentSpec SegmentSpec => (Spec as SegmentSpec)!;
    public Dictionary<Side, List<Socket>> Sockets = new();
    public Crawler Crawler { get; private set; }

    public override string ToString() => $"{SegmentSpec}";
    public override string LongString => $"{base.LongString} SEG[{SegmentSpec}]";

    public override IEnumerable<Component> Tree {
        get {
            yield return this;
            foreach (var sockets in Sockets.Values) {
                foreach (var socket in sockets) {
                    foreach (var c in socket.Tree) {
                        yield return c;
                    }
                }
            }
        }
    }
    override public string TypeName => "  Segment";
}

class Crawler: Component
{
    public Crawler(string name, CrawlerSpec spec): base(spec)
    {
        foreach (var segmentSpec in spec.Segments) {
            Segments.Add(new Segment(this, segmentSpec));
        }
        Name = name;
    }
    public readonly string Name;
    public CrawlerSpec CrawlerSpec => (Spec as CrawlerSpec)!;
    public List<Segment> Segments = new();
    public override string ToString() => $"{Name}";
    //public override string LongString => $"{ConsoleColor.Yellow.On(ConsoleColor.DarkRed)}{Name}\e[m: {base.LongString}";
    public override string LongString => Style.Name.Format(Name) + $" {base.LongString}";
    public override IEnumerable<Component> Tree {
        get {
            yield return this;
            foreach (var segment in Segments) {
                foreach (var c in segment.Tree) {
                    yield return c;
                }
            }
        }
    }
    override public string TypeName => "Crawler";
}

class Socketable: Component {
    public Socketable(Socket? socket, SocketableSpec spec): base(spec) {
        Socket = socket;
    }
    public SocketableSpec SocketableSpec => (Spec as SocketableSpec)!;
    public override string TypeName => "    <socketable>";
    public Socket? Socket {
        get {
            return _socket;
        }
        set {
            if (_socket != null) {
                _socket.Socketed = null;
            }
            _socket = value;
            if (_socket != null) {
                _socket.Socketed = this;
            }
        }
    }
    Socket? _socket = null;
}

class Traction: Socketable {
    public Traction(Socket socket, TractionSpec spec): base(socket, spec) {
    }
    public void AttachDB(List<TractionTerrainSpec> terrainSpecs) {
        foreach (var spec in terrainSpecs) {
            TerrainSpecs[spec.TerrainType] = spec;
        }
    }
    public TractionSpec TractionSpec => (Spec as TractionSpec)!;
    public override string ToString() => $"{TractionSpec}";

    public readonly Dictionary<TerrainType, TractionTerrainSpec> TerrainSpecs = new();
}
